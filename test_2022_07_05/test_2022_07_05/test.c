#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>

/*****数据存储*****/

//int main()
//{
//	int a = 20;
//	//0000 0000 0000 0000 0000 0000 0001 0100 -原码
//	//0000 0000 0000 0000 0000 0000 0001 0100 -反码
//	//0000 0000 0000 0000 0000 0000 0001 0100 -补码
//	//正数反码和补码和原码相同
//	//0x00000014 -补码十六进制
//	int b = -10;
//	//1000 0000 0000 0000 0000 0000 0000 1010 -原码
//	//1111 1111 1111 1111 1111 1111 1111 0101 -反码 //原码符号位不变，其余取反
//	//1111 1111 1111 1111 1111 1111 1111 0110 -补码 //反码加一
//	//0xFFFFFFF6 -补码十六进制
//
//	//正数和负数在内存中均以补码的形式存储，因为CPU只有加法器，以补码形式存储，可以让加法和减法均以加法的形式进行处理。
//	//1的补码为： 0000 0000 0000 0000 0000 0000 0000 0001
//	//-1的补码为：1111 1111 1111 1111 1111 1111 1111 1111
//	//相加为0
//
//	//大端存储：数据低位存储在高地址，高位存储在低地址   //也叫大端字节序
//	//小端存储：数据低位存储在低地址，高位存储在高地址   //也叫小端字节序
//	return 0;
//
//}


//int main()
//{
//	int a = 1;
//	int* p =&a;
//	printf("%d\n",*(((char*)p)));  //判断存储方式,1为小端,0为大端
//	return 0;
//}

//int main()
//{
//	char a = -1;
//	signed char b = -1;
//	unsigned char c = -1;
//	//补码：1111 1111 1111 1111 1111 1111 1111 1111
//	//c中存储内容为：1111 1111
//	printf("%d %d %d\n",a,b,c);
//	//整型提升规则：数据类型为无符号，高位补零；数据类型为有符号，高位补符号位
//	//a打印时整型提升为：1111 1111 1111 1111 1111 1111 1111 1111  其原码为：1000 0000 0000 0000 0000 0000 0000 0001  //-1
//	//c打印时整型提升为：0000 0000 0000 0000 0000 0000 1111 1111  其原码为：0000 0000 0000 0000 0000 0000 1111 1111  //255
//	return 0;
//}

//int main()
//{
//	char a = -128;
//	//1000 0000 0000 0000 0000 0000 1000 0000
//	//1111 1111 1111 1111 1111 1111 0111 1111
//	//1111 1111 1111 1111 1111 1111 1000 0000  //补码
//	//1000 0000
//	//1111 1111 1111 1111 1111 1111 1000 0000  //整型提升
//	char b = 128;		//128=127+1  //0111 1111+1 = 1000 0000  //10000 0000 = -128
//	printf("%u   %u\n",a,b);		//%u:打印十进制无符号数字，无符号数字补码等于原码，故整型提升后的即为原码
//	return 0;
//}

//有符号char的范围：-128~127
//无符号char的范围：0~255

//int main()
//{
//	
//	char a = 128;  //128=127+1  //01111111+1=10000000
//	//00000000000000000000000010000000
//	//10000000
//	//11111111111111111111111110000000  //整型提升
//	//11111111111111111111111101111111
//	//10000000000000000000000010000000  //整型提升后的原码
//	printf("%d\n",a);
//	return 0;
//}


//int main()
//{
//	int i = -20;
//	//1000 0000 0000 0000 0000 0000 0001 0100  //-20原码
//	//1111 1111 1111 1111 1111 1111 1110 1011  //-20反码
//	//1111 1111 1111 1111 1111 1111 1110 1100  //-20补码
//	unsigned int j = 10;
//	//0000 0000 0000 0000 0000 0000 0000 1010  //10补码
//	printf("%d\n",i+j);
//	//1111 1111 1111 1111 1111 1111 1111 0110  //-20+10补码
//	//1111 1111 1111 1111 1111 1111 1111 0101
//	//1000 0000 0000 0000 0000 0000 0000 1010  //-20+10原码
//	//-10
//	return 0;
//}

//#include <windows.h>
//int main()
//{
//	unsigned int i;
//	for(i=9;i>=0;i--)
//	{
//		printf("%u\n",i);
//		Sleep(100);
//	}
//	//1111 1111 1111 1111 1111 1111 1111 1111  //-1
//
//	return 0;
//}


//#include <string.h>
////fallible
//int main()
//{
//	char a[1000];		//char的范围是-128到127
//	int i;
//	for(i=0;i<1000;i++)
//	{
//		a[i] = -1-i;
//	}
//	printf("%d\n",strlen(a));		//strlen读取0或'\0'之前的字节数
//	//-129 = -128+(-1)
//	//1000 0000 0000 0000 0000 0000 1000 0000  //-128原码
//	//1111 1111 1111 1111 1111 1111 0111 1111  //-128反码
//	//1111 1111 1111 1111 1111 1111 1000 0000  //-128补码
//	//1111 1111 1111 1111 1111 1111 1111 1111  //-1补码
//	//0000 0000 0000 0000 0000 0000 0111 1111  //-128+(-1)补码(原码)
//	//127
//	return 0;
//}

//unsigned char i =0;		//unsigned char的范围为0到255		//用无符号数作为循环的判断条件要考虑清楚范围
//int main()
//{
//	for(i=0;i<=255;i++)		//条件恒成立
//	{
//		printf("hello there\n");
//	}
//	//256=255+1
//	//0000 0000 0000 0000 0000 00001111 1111
//	//0000 0000 0000 0000 0000 00000000 0001
//	//1 0000 0000
//	//0000 0000  //截断
//	return 0;
//}

/*****浮点数存储*****/

//整型数据范围定义在limits.h中，浮点型数据范围定义在float.h中
//任意一个浮点数可表示为：(-1)^S*M*2^E
//(-1)^S为符号位，S=0，V为正数；S=1，V为负数
//M表示有效数字，大于等于1，小于2
//2^E表示指数位
//在32位的浮点数中：最高位为S，接着8位为E，然后23位为M
//在64位的浮点数中：最高位为S，接着11位为E，然后52位为M
//M只存小数点后的部分
//存E时，若E为8位，中间值为127，若E为11位，中间值为1023
//E可能为负数，故存入的值为E加中间值

//int main()
//{
//	int n = 9;
//	float *pfloat = (float*)&n;
//	printf("n的值为 %d\n",n);
//	printf("float的值为 %f\n",*pfloat);
//
//	*pfloat = 9.0;		//0.5：(-1)^0*1.0*2^1
//	//1001.0  //
//	//1.001*2^3
//	//(-1)^0*1.001*2^3
//	//S - 0
//	//M - 1.001
//	//E - 3
//	printf("n的值为 %d\n",n);
//	printf("float的值为 %f\n",*pfloat);
//	return 0;
//}

//int main()
//{
//	float f = 5.5;
//	//5.5
//	//101.1
//	//(-1)^0*1.011*2^2
//	//S = 0
//	//M = 1.011
//	//E = 2
//	//0 10000001 01100000000000000000000		//为什么补零补后面？  //E零补左边  //M零补右边，因为取出的时候是从左往右取，将011取出
//	//0x40b00000
//	//E为：10000001
//	//E不为全零或全一：E减去127(1023)为真实值
//	//E为全零：说明所存值为无穷小  //？  //为了表示+_0,以及接近于0的很小的数字,M不再加上第一位
//	//E为全一：说明所存值为正负无穷大  //？
//	return 0;
//}